/**
 *  变量、作用域和内存问题
 *      基本类型和引用类型
 *          基本类型 
 *              简单的数据段
 *              按值访问 操作保存在变量中的实际值
 *              不可以添加属性
 *          引用类型 
 *              多个值构成的对象
 *              按引用访问 操作对象的引用而不是实际值(JS不允许直接访问内存中的位置)
 *                  复制变量 是当前引用指针的副本
 *                  给对象添加属性 是操作的实际对象
 *              可以添加属性
 *      复制变量值
 *          基本类型
 *              拷贝一个变量的副本赋值给新变量
 *          引用类型        
 *              拷贝一个副本赋值给新变量 副本是一个指针 两个变量指向同一块内存区
 *      
 *      传递参数
 *          ES中所有函数的参数都是按值传递的（同复制变量值操作相同）
 *          ES中的参数可以看做局部变量
 * 
 *  检测类型
 *      基本类型的检测使用 typeof
 *          
 *      引用类型的检测使用 instanceOf
 *          result = variable instanceOf constructor
 *          检测 variable.__proto__ 与 constructor.prototype 的关系
 * 
 *  执行环境及作用域
 *      执行环境
 *          定义了变量或函数有权访问的其他数据，决定了他们的各自行为
 *          每个执行环境都有一个与之关联的变量对象，执行环境中定义的所有变量和函数都保存在变量对象上
 *      函数有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行的之后，栈将其环境弹出，把控制权返回给之前的执行环境
 *      代码在一个环境中执行的时候 创建一个变量对象的作用域链
 *      作用域链
 *          保证对执行环境有权访问的所有变量和函数的有序访问
 *      标识符解析的过程就是沿着作用域链一级一级的搜索标识的过程
 *      内部环境可以通过作用域链访问所有的外部环境 但是外部环境不能访问内部环境的任何变量和函数
 * 
 *      延长作用域链
 *          try...catch catch语句
 *          with
 * 
 *      没有块级作用域
 *          声明变量
 *              会被添加到最近的环境中
 *          查询标识符
 *              某个环境中读取或写入一个标识符的时候，会进行作用域链查找 知道作用域链的最底端
 *              JS的变量查询不会浪费太大性能 没有问题
 * 
 *  垃圾回收
 *      执行环境会负责管理代码执行过程中使用的内存
 *      局部变量只有在执行的过程中存在 在这个过程中 会为局部变量在内存堆(栈)中分配相应的空间 以便存储他们的值
 *      
 *      标记清除
 *      引用计数
 *        
 *      性能问题
 *      管理内存
 *          解除引用的真正作用是让值脱离执行环境，以便于垃圾回收机制收集
**/
void function() {
    var count = 20;
    function add(count) {
        count = count + 10
        return count;
    }
    var  result = add(count);
    console.log(result, count) // 30 20 count没有被修改 证明基本类型是按照值传递 拷贝了一个值得副本



    function setName(obj) {
        obj.name = 'lxk'
    }
    var person = new Object();
    setName(person)
    console.log(person.name) // lxk 虽然打印出了lxk 但是不能证明引用类型的传递是按值传递还是按照引用传递


    function setName1(obj) {
        obj.name = '值传递'
        obj = new Object();
        obj.name = '引用传递'
    }
    var person1 = new Object();
    setName1(person1)
    console.log(person1.name)  // 值传递 可以证明不是按引用传递 按引用传递会指向新对象 并添加属性name='引用传递'
}();
void function() {
    // 可以在控制台看 回调栈 变量对象的作用域链
    var a = 1;
    function foo() {
        
        console.log(a)
    };

    (function() {
        var a = 2;
        foo()
    })();
}();