/**
 * 还是不太理解渲染引擎是如何按照上下文分配图层的?????
 * 
 *  06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？
 *      分层(图层树)
 *          布局树生成完成，节点坐标位置计算完成，接下来生成图层树
 *          为什么要生成图层树？
 *              页面中有很多复杂的交互效果，一些复杂的3D变换、页面滚动、或者使用z-index做z轴排序等，为了更
 *              方便实现这些效果，渲染引擎为特定的节点生成专用图层，并生成一颗对应的图层树
 *          通常并不是布局树的每个节点都生成一个layer，如果对应的节点没有layer，那么节点从属于父节点的layer
 *          满足什么条件，渲染引擎才会为特定的节点创建新的layer呢？
 *              拥有层叠上下文属性的元素会被提升单独的一层（层叠上下文解析见 E1 ）
 *              需要剪裁（clip）的地方也会被创建为图层
 *      图层绘制（输出绘制列表）
 *          渲染引擎会将图层绘制切分成很多小的绘制指令，将这些指令生成一个待绘制列表
 *          绘制列表是一个记录绘制顺序和绘制指令的列表
 *          chrome->layer->层->Profiler可以拖动进度条重现列表的绘制过程  
 *          完成图层树的构建，渲染引擎会对图层树进行绘制        
 *      栅格化操作(raster) 图见 ./i/栅格化.png
 *          栅格化 将图块生成位图
 *          主线程生成绘制列表之后，会将绘制列表提交给合成线程
 *          合成线程将图层划分为图块，将视口附近的的图块先生成位图，实际生成位图的操作由栅格化线程来执行
 *          图块是栅格化执行的最小单位，渲染进程维护了一个栅格化的线程池
 *          通常情况，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化/GPU栅格化 生成的位图保存在GPU内存中
 *      合成和显示
 *          一旦所有的图块都被光栅化，合成线程就会生成一个绘制图块的命令（DrawQuad），将该命令提交给浏览器进程
 *          浏览器内部有一个viz组件，用来接收合成线程发过来的DrawQuad命令，将其内容绘制到内存中，最后将内容显示在屏幕上
 *      渲染流水线大总结 图见 ./i/完整的渲染流水线示意图.png
 *          渲染进程将HTML解析成浏览器能够识别的DOM树
 *          渲染引擎将CSS样式表转换成浏览器可以理解的styleSheets，计算出DOM节点的样式
 *          创建布局树，并计算元素的布局信息
 *          为每个图层生成绘制列表，并将其提交给合成线程
 *          合成线程将图层分块，并在光栅化线程池中将图块转换成位图
 *          合成线程发送绘制图块命令DrawQuad给浏览器进程
 *          浏览器进程根据DrawQuad消息生成页面，并显示到浏览器上
 *     
 *          
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 *  
**/

/**
 *  
 *  E1：
 *  层叠上下文是什么？
 *      假定用户面向浏览器网页，而HTML元素沿着其相对于用户的一条虚拟的z轴排开，层叠上下文就是对这些HTML元素的一个三维构想
 *      众HTML元素基于元素属性按照优先级占据空间
 *  形成层叠上下文条件
 *      文档根元素html
 *      position值为absolute/relative,z-index值不为auto的元素
 *      position值为fixed/sticky
 *      flex/grid容器的子元素，且z-index值不为auto
 *      opacity值小于1的元素
 *      以下任意属性值不为none的元素
 *          transform 
 *          filter  
 *          perspective 
 *          clip-path  
 *          mask/mask-image/mask-border 
 *      -webkit-overflow-scrolling值为touch
 *  
 *  层叠上下文总结：
 *      层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级
 *      每个层叠上下文都完全独立于他的兄弟元素，当处理层叠时值考虑子元素
 *      每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将作为整体在父级层叠上下文中按顺序进行层叠
**/