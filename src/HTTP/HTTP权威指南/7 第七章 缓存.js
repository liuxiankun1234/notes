/**
 *  疑问
 *      一个网址，有1万个人访问 这个时候会是什么情况啊
 * 
 * 第七章 缓存
 *  
 *  为什么会用到缓存这个东西呢？或者说缓存有什么好处
 *      缓存减少了冗余的数据传输
 *      缓存缓解了网络瓶颈的问题，不需要更多的带宽就能更快地加载页面
 *      缓存降低了对原始服务器的要求，服务器可以更快地响应，避免过载的出现
 *      缓存降低了距离延时，因为从较远的地方加载页面会更慢一些
 *  
 *  冗余的数据传输
 *      很多客户端访问同一个流行的原始服务器页面时，服务器会多次传输同一份文档，每次传输给一个客户端。一些相同的
 *      字节会在网络中一遍遍的传输。这些冗余的数据会耗尽昂贵的带宽，降低传输速度，加重Web服务器的负载。
 *      有了缓存就可以保留第一条服务器响应的副本，后续请求就可以由缓存的副本来应对了，这样可以减少那些流入/流出原始
 *      服务器的、被浪费掉的重复流量
 *  带宽瓶颈
 *      缓存还可以缓解网络的瓶颈问题
 *      很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽，客户端会以路径上最慢的网速访问服务器。
 *      如果客户端从一个快速局域网的缓存中得到一份副本，那么缓存就可以提高性能 尤其是传输比较大的文件时
 *  瞬间拥塞
 *      缓存在破坏瞬间拥塞时显得非常重要。
 *      突发事件使得很多人几乎同时访问一个Web文档时，就会出现瞬间拥塞。由此造成的过多流量峰值可能会使网络和Web服务器产生灾难性的崩溃
 *  距离时延
 *      即使带宽不是问题，距离也可能成为问题。每台网络路由器都会增加因特网流量的时延，即使客户端和服务器之间没有太多的路由器，光速本身也会造成
 *      显著的时延。
 *      波士顿到旧金山直线距离是2700英里，最好的情况下，以光速传（186000英里/秒）播的信号可以在15毫秒内从波士顿到达旧金山，并在30毫秒完成一个往返
 *      假设某个Web页面中包含了20个小图片，都在旧金山的一台服务器上。如果波士顿的一个客户端打开4条到服务器并行连接，而且保持着连接的活跃状态，光速自身就要消耗
 *      大约1/4秒的下载事件
 *      将缓存放在附件的机房可以将文件传输距离从数千英里缩短为数十米
 *  命中与未命中
 *      缓存命中
 *          可以用已经有的副本为某些到达缓存的请求提供服务
 *      缓存未命中
 *          其他一些到达缓存的请求可能由于没有副本可用，而被转发给原始服务器
 *      再验证(新鲜度检测)
 *          原始服务的内容可能会发生变化，缓存要不时的对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本，这些新鲜度检测被称为HTTP再验证
 *          为了有效的进行再验证，HTTP定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的
 *          缓存可以在任意时刻，以任意的频率对副本进行再验证。不过缓存中通常包括数百万的文档，而且网络带宽很珍贵，所以大部分缓存只在客户端发起请求，并且副本旧到足以需要验证的时候，才对副本进行再验证
 *              再验证命中（缓慢命中）
 *                  缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有发生变化，服务器会以一个小的304 Not Modified进行响应，并将副本提供给客户端
 *                  比单纯的缓存命中要慢，但是再验证命中没有从服务器中获取对象数据，所以比缓存未命中要快
 *              再验证未命中
 *                  服务器端与缓存的副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP 200 OK响应
 *              对象被删除 
 *                  如果服务器对象已经被删除，服务器就会发送一个404 Not Found响应，缓存也将其副本删除
 *  命中率（缓存命中比率）
 *      ？？？？？？？？？？
 *  缓存的拓扑结构
 *      ？？？？？？？？？？       
 *  缓存的处理步骤
 *      商业化代理缓存相当复杂。除了一些微妙的细节之外，Web缓存的基本工作原理大多很简单
 *      一条HTTP get请求的基本缓存处理过程包括7个步骤
 *          接收
 *              缓存从网络中读取抵达的请求报文
 *              高性能缓存会同时从多条输入连接上读取数据，在整条报文抵达之前开始对事务进行处理
 *          解析
 *              缓存对报文进行解析，提取URL和各种首部字段
 *              缓存将请求报文解析成片段，将首部的各个部分放入易于操作的数据结构中。
 *          查询
 *              缓存查询是否有本地副本可用，如果没有，就获取一份副本（并将其保存在本地）
 *              缓存获取了URL，查找本地副本。本地副本可能存储在内存、本地磁盘，甚至附件的另一台计算机中。专业级的缓存会使用算法来快速确定本地缓存中是否有某个对象。如果没有这个文档，他可以根据情形和配置，到原始服务器或父代理中取，或者返回一些错误信息
 *              已缓存对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中之后返回正确的服务器首部。已缓存对象中还包括了一些元数据，用来标记对象在缓存中停留了多久，以及他被用过多少次
 *          新鲜度检测
 *              缓存查看已缓存的副本是否足够新鲜，如果不是，就询问服务器是否有任何更新
 *          创建响应
 *              缓存会用新的首部和已缓存的主体来构建一条响应报文
 *              我们希望缓存的响应看起来像来自服务器的一样，缓存将已缓存的服务器响应首部作为响应首部的起点，然后缓存对这些基础首部进行了修改和扩充
 *              缓存负责对这些首部进行改造，以便与客户端的要求相匹配
 *                  比如客户端期待一条HTTP/1.1响应，但是服务器返回的可能是1.0版本，这种情况，缓存必须对首部进行响应的转换
 *                  缓存还会向其中插入新鲜度信息（cache-Control,Age以及Expires首部），而且通常会包含一个Via首部来说明请求是一个代理缓存提供的
 *          发送
 *              缓存通过网路将响应传递给客户端
 *          日志
 *              缓存可选的创建一个日志文件描述这个事务
 *  保持副本的新鲜
 *      服务器资源的变化频率不同，财经数据可能每几秒就会变化、报纸每天变化、报告可能几个月发生变化，如果缓存提供的总是老的数据，就变的毫无用处
 *      已缓存的副本要与服务器一致
 *      文档过期（服务器再验证）
 *          Cache-Control首部和Expires首部
 *          HTTP让原始服务器向每一个文档附加一个'过期日期'，这些首部
 *                         
*/      