/**
 *  第三章节 HTTP报文
 *      本章阅读可以理解
 *          报文是如何流动的
 *          HTTP报文的是三个组成部分（起始行、首部和实体的主体部分）
 *          请求和响应报文之间的区别
 *          请求报文支持的各种功能
 *          和响应报文一起返回的状态码
 *          各种各样的HTTP请求首部是用来做什么的
 *      报文流
 *          HTTP报文流是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容以及含义，后面跟着可选的数据部分
 *          这些报文在客户端、服务器、代理之间流动。术语 流入 流出 上游 下游
 * 
 *          报文流入源端服务器
 *              HTTP使用术语流入和流出来描述事物处理的方向。
 *              报文流入源端服务器，工作完成之后，会流回用户的Agent代理中
 *          报文向下游流动
 *              HTTP报文像河水，不论是响应报文还是请求报文，所有的报文都会向下游流动
 *              多有报文的发送者都在接收者的上游
 *      报文的组成部分
 *          HTTP报文是简单的格式化数据块。每条报文都包含一个来自客户端的请求，或者服务器的响应。  
 *          组成部分
 *              起始行(start line) 
 *                  对报文进行描述
 *              首部(header)
 *                  包含属性
 *              主体(body)
 *                  可选、包含数据
 *              起始行和首部是由行分隔的ASCII文本、每行都以一个由两个字符组成的行终序列作为结束。其中包含一个回车符(\r)和一个换行符(\n)
 *              这个终止序列可以写作CRLF。需要指出的是，尽管HTTP规范中说明应该用CRLF来表示终止，但稳健的应用程序也应该接受单个换行符作为行的终止，有些老的，或者不完整的HTTP应用程序并不总是既发送\r，又发送\n
 *              实体的主体或者报文的主体是一个可选的数据块，与起始行不和首部不同的是，主体中可以包含文本或二进制数据，也可以是空
 *          报文的语法
 *              所有的HTTP报文分为两类
 *                  请求报文 
 *                  响应报文
 *              请求报文格式
 *                  <method> <request-URL> <version>\r\n
 *                  <headers>\r\n
 *                  \r\n
 *                  <entity-body>
 *              响应报文格式
 *                  <method> <status> <reason-phrase>\r\n
 *                  <headers>\r\n
 *                  \r\n
 *                  <entity-body>
 *              方法（method）
 *                  客户端希望服务器对资源执行的动作。GET POST ...
 *              请求URL(request-URL)
 *                  命名了请求资源，或者URL路径组件的完整URL。如果直接与服务器进行对话，只要URL的路径组件是资源的绝对路径，服务器可以假定自己的URL的主机/端口
 *              版本(version)
 *                  报文使用的HTTP版本，其格式看起来是
 *                      HTTP/<major>.<minor>
 *                      major:主版本号
 *                      minor:次要版本号
 *              状态码(status-code)
 *                  这三位数描述了请求过程中的所发生的的情况 成功/失败
 *              原因短语(reason-phrase)
 *                  状态码的可读版本，包含行终止序列之前的所有文本
 *              首部（headers）
 *                  可以由零个或多个首部，每个首部都有一个名字，后面跟一个冒号，然后是一个可选的空格，接着是一个值，最后是一个CRLF(\r\n)
 *                  有些HTTP版本（HTTP/1.1）要求有效的请求或者响应报文中必须包含特定的首部
 *              实体的主体部分
 *                  实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分
 *          起始行
 *              所有的HTTP报文都以一个起始行作为开始。请求报文的起始行说明了要做些什么事，响应报文的起始行说明发生了什么事
 *              请求行（请求报文的起始行）
 *                  请求报文请求服务器对资源进行一些操作
 *                  请求报文的起始行包含一个方法和一个请求URL和一个HTTP版本
 *                      这个方法描述了服务器应该执行什么操作
 *                      这个URL描述了对哪个资源执行这个方法
 *                      这个HTTP版本用来告知服务器客户端使用的哪种HTTP
 *                  所有这些字段都以空格符分隔 HTTP/1.0之前并不要求请求行中包含HTTP版本号
 *              响应行（响应报文的起始行）
 *                  响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。
 *                  响应报文的起始行包含 响应报文使用的HTTP版本、数字状态码、原因短语 
 *                  所有这些字段都以空格符分隔 HTTP/1.0之前并不要求请求行中包含HTTP版本号
 *              方法
 *                  请求的起始行以方法作为开始，方法用来告知服务器做什么
 *                  比如 GET方法从服务获取资源 POST向服务器发送需要处理的数据 OPTIONS方法用来确定Web服务器的一般功能，或者Web服务器处理特定资源的能力
 *                  由于HTTP设计的易于扩展，所以除了这些方法之外，其他服务器可能还会实现一些自己的请求方法
 *              状态码
 *                  方法用来告诉服务器做什么事，状态码则是用来告诉客户端，发生了什么事情。
 *                  状态码位于响应起始行中
 *              原因短语
 *                  原因短语是响应起始行中的最后一个组件。它为状态码提供了文本形式的解析
 *              版本号
 *                  版本号会以HTTP/x.y的形式出现在请求和响应报文的起始行中。为HTTP程序提供了一种将自己所遵循的协议版本告知对方的方式
 *                  使用版本号的目的是为了使用HTTP的应用程序提供一种线索，以便互相了解对方的能力和报文格式。
 *                  在与使用HTTP/1.1的应用程序进行通信的HTTP/1.2应用程序应该知道，他不能使用任何的1.2特性，因为使用老版本协议的应用可能无法实现这些特性
 *                  版本号说明了应用支持的最高HTTP版本。
 *                  版本号不会当做小数来比较 HTTP/2.22 比 HTTP/2.3版本高 因为22 > 3
 *          首部
 *              HTTP首部向请求和响应报文中添加了一些附加信息。本质上来说他们只是一些名/值对的列表
 *              首部分类
 *                  通用首部
 *                      既可以出现在请求报文中，又可以出现在响应报文中
 *                  请求首部
 *                      提供更多的请求信息
 *                  响应首部
 *                      提供更多的响应信息
 *                  实体首部
 *                      描述实体的长度和内容或者资源自身
 *                  扩展首部
 *                      规范中没有定义的首部
 *              语法 名字后面跟一个冒号，然后是一个可选的空格，再跟上一个字段值 最后是一个CRLF
 *              首部延续行
 *                  将长的首部分为多行可以提高可读性，多出来的每行前面至少有一个空格或者制表符（tab）                
 *          实体的主体部分
 *              HTTP报文的第三部分是可选的实体主体部分。实体的主体是HTTP报文的负荷，即使HTTP要传输的内容
 *      方法
 *          安全方法
 *              HTTP定义了一组被称为安全方法的方法 GET方法和HEAD方法就是安全方法 意味着GET方法和HEAD方法的HTTP请求都不会对产生什么动作
 *          GET方法
 *              GET方法是最常用的方法。通常用于请求服务器上的某个资源
 *              HTTP/1.1要求服务器端实现GET方法
 *              通常的页面访问就是GET方法
 *          HEAD方法
 *              服务器在响应中仅返回首部，不会返回实体内容
 *              这就允许客户端在未获取到实际资源的情况下，对资源的首部进行检查
 *              使用HEAD可以
 *                  在不获取资源的情况下了解资源的情况 比如判断其类型
 *                  通过查看响应中的状态码，看看某个对象是否存在
 *                  通过查看首部，测试资源是否被修改过
 *          PUT方法
 *              与GET会向服务器请求资源相反，PUT方法会向服务器写入文档
 *              PUT方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者这个URL已经存在的话，就用这个主体来替代它 
 *              因为PUT方法会对内容进行修改，所以很多Web服务器都要求在执行PUT方法前，用密码登录
 *          POST
 *              POST方法是用来向服务器输入数据的。
 *          TRACE
 *              客户端发起一个请求，很可能经过防火墙、网关或者其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子
 *              TRACE请求会在目的服务器发起一个’环回‘诊断。形成最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带他收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求和响应链上，原始报文是否，以及如何被毁坏或修改
 *              TRACE方法主要用于诊断，也就是说用于验证请求是否如愿穿过了请求/响应链。它是一种很好的工具，可以查看代理和其他应用程序对用户请求所产生的的效果
 *              TRACE缺点
 *                  TRACE假定中间应用程序对不同类型的请求处理是相同的，但是很多HTTP应用程序会根基方法的不同作出不同的事---比如，代理可能会将POST请求转发服务器，将GET请求发送给另一个HTTP应用程序。
 *                  TRACE并不提供区分这些方法的机制，通常中间应用程序会自行决定对TRACE请求的处理方式
 *              TRACE请求中不能带有实体的主体部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本 
 *          OPTIONS
 *              OPTIONS方法请求Web服务器告知其支持哪种功能，可以查询服务器通常支持哪些方法，或者对其某些特殊资源支持哪些方法（某些服务器可能只支持对一些特殊类型的对象使用特定的操作）
 *              这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判断是否可以访问改资源的最优方式
 *          DELETE
 *              DELETE方法是请服务器删除URL所指定的资源，但是客户端无法保证删除操作一定会被执行
 *              因为HTTP规范允许服务器在不通知客户端的情况下撤销请求
 *          扩展方法
 *              HTTP被设计成字段可扩展的，这样新的特性就不会使老的软件失效了。扩展方法值得就是没有在HTTP/1.1规范中定义的方法
 *              服务器会为它所管理的资源实现一些HTTP服务，这些方法为开发者提供了一种扩展这些HTTP服务能力的手段。
 *              Web扩展方法示例
 *                  LOCK        允许用户‘锁定‘资源--比如可以在编辑某个资源的时候将其锁定，以防止别人同时对其进行修改
 *                  MKCOL       允许用户创建资源
 *                  COPY        便于在服务器上复制资源
 *                  MOVE        在服务器上移动资源
 *              并不是所有扩展方法都是正式规范中定义的，认识到这一点很重要。如果你定义一个扩展方法，很可能大部分HTTP应用程序都无法理解，同样，你的HTTP应用程序也可能会遇到其他应用程序都在用，他们无法理解的扩展方法
 *              在这种情况下，对所有发出去的内容严格一点，对所接受的内容宽松一点来处理扩展方法
 *      状态码
 *          状态码为客户端提供了一种理解事务处理结果的便捷方式。
 *          尽管并没有实际的规范对原因短语的确切文本进行说明，本节还是列出了一些原因短语实例
 * 
 *          100~199  信息性状态码
 *          200~299  成功状态码
 *              客户端发起请求时，大部分都是成功的。服务端定义了部分表示成功的状态码，分别对应于不同类型的请求
 *              200
 *                  原因短语     OK
 *                  含义        请求没有问题，实体的主体部分包含了所请求的资源
 *              201
 *                  原因短语     Created
 *                  含义        用于创建服务器对象的请求(例如：PUT)，响应的实体主体部分中应该包含各种引用了已创建的资源的URL，Location首部包含的则是最具体的引用
 *                             服务器必须在发送这个状态码之前创建好对象
 *              202
 *                  原因短语     Accepted
 *                  含义        请求已被接收，但服务器还未对其进行任何动作。不能保证服务器会完成这个请求；这只意味着接收请求时，它是有效的
 *                              服务器应该在实体的主体部分包含对请求状态的描述，获取还应该有对请求完成时间的预估（或者包含一个指针，指向可以获取此信息的位置）
 *              203   
 *                  原因短语     Non-Authoritative Information
 *                  含义        表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确
 *              204
 *                  原因短语     No Content
 *                  含义        在并没有新文档的情况下，204确保浏览器继续显示先前的文档
 *                             响应报文中包含若干首部和一个状态行，但是没有实体的主体部分
 *                             主要用于在浏览器不转为显示新文档的情况下，对其进行更新（例如刷新一个表单列表）      
 *              205
 *                  原因短语     Reset Content
 *                  含义        虽然没有新文档但浏览器要重置文档显示
 *                             另一个主要用于浏览器的代码，负责告知浏览器清除当前页面中所有的HTML表单元素
 *              206
 *                  原因短语     Partial Conent
 *                  含义        成功执行了一个部分或者Range（范围）请求
 *          300~399  重定向状态码
 *              重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。
 *              如果资源已被移动，可发送一个重定向状态码和一个可选的Location首部来告知客户端资源已被移走，以及现在可以在哪找到它
 *              可以通过某些重定向状态码对资源的应用程序本地副本与源端服务器上的资源进行验证。比如HTTP应用程序可以查看其资源的本地副本是否仍然是新鲜的
 *              对那些包含了重定向状态码的非HEAD请求进行响应时，最好要包含一个实体，并在实体中包含描述信息和指向(多个)重定向URL的链接。
 *              300
 *                  原因短语     Multiple Choice
 *                  含义        客户端请求一个实际上指向多个资源的URL时会返回这个状态码，比如服务器上有一个资源的不同语言版本，返回代码时会带有一个选项列表，用户就可以选择他希望使用的那一项了
 *              301 永久重定向
 *                  原因短语     Moved Permanently
 *                  含义        在请求的URL已经被移除时使用。响应的Location首部中包含资源现在所处的URL
 *              302 临时重定向
 *                  原因短语     Found
 *                  含义        与301状态码类似；但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求应使用老的URL
 *              303 
 *                  原因短语     See Other
 *                  含义        告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的Location首部。其目的是允许POST请求的响应将客户端定向到某个资源上去
 *                              303应禁止被缓存
 *              304 条件请求
 *                  原因短语     Not Modified
 *                  含义        客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发送一条GET请求，而最近资源未修改，可以返回该状态码
 *                              带有304状态码的响应不应该包含实体
 *              305
 *                  原因短语     Use Proxy
 *                  含义        用来说明必须通过一个代理来访问资源；代理的位置有Location首部给出。
 *                             很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求
 *              306
 *                  原因短语     
 *                  含义        当前未使用
 *              307
 *                  原因短语     Temporary Redirect 
 *                  含义        与302状态码类似。客户端应该使用Location首部给出的URL来临时定位资源。将来的请求应该使用老的URL
 *              308 
 *                  原因短语     Permanent Redirect
 *                  含义        表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上
 *              301 302 303 307 308区分
 *              301 308 都是永久重定向
 *              302 307 都是临时重定向
 *              301 302
 *                  是HTTP/1.0的状态码
 *                  重定向之后可以改变请求方式 原POST请求 重定向之后改为GET请求
 *              307 308
 *                  是HTTP/1.0的状态码
 *                  重定向不可以改变请求方式
 *              303 
 *                  该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求资源
 *                  303和302有相同的功能，但是303状态码有明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别
 *              301 302 303响应状态码返回时，几乎所有的浏览器都会把POST改成GET请求，并删除请求报文内的主体，之后请求会再次发送
 *              301 302标准是进制POST方法改成GET方法的，但实际使用时大家都会这么做
 *          400~499  客户端错误状态码
 *              客户端发送一些服务器无法处理的东西。错误的URL地址，错误个请求报文等
 *              400
 *                  原因短语    Bad Request   
 *                  含义       用于告知客户端它发送了一个错误的请求
 *              401
 *                  原因短语    Unauthorized   
 *                  含义       与适当的首部一起返回，在这些首部中请求客户端在获取对资源的访问之前，对自己进行认证
 *              402
 *                  原因短语    Payment Required
 *                  含义       现在这个状态码还未使用，但已经被保留，以作未来只用
 *              403
 *                  原因短语    Forbidden  
 *                  含义       服务器拒绝请求。如果服务器想说明为什么拒绝请求，可以包含实体的主体部门来对原因进行描述
 *              404
 *                  原因短语    No Found
 *                  含义       服务器无法找到请求的URL
 *              405
 *                  原因短语    Method Not Allowed
 *                  含义       发起的请求带有服务器不支持的方法，应该在响应中包含Allow首部，以告知客户端对所请求的资源可以使用哪些方法
 *              406
 *                  原因短语    Not Acceptable 
 *                  含义       客户端可以指定参数来说明它们愿意接受什么类型的实体。服务器没有与客户端可接受的URL相匹配的资源时，使用此代码。通常服务器会包含一些首部，以便客户端弄懂为什么无法满足
 *              407
 *                  原因短语    Proxy Authentication Required    
 *                  含义       与401状态码类似，但用于要求对资源进行认证的代理服务器
 *              408
 *                  原因短语    Request Timeout
 *                  含义       客户端完成请求所花时间太长，服务器可以回送此状态码，并关闭链接
 *              409
 *                  原因短语    Conflict  
 *                  含义       用于说明请求可能在资源上引发一些冲突。响应中包含描述冲突的主体
 *              410
 *                  原因短语    Gone    
 *                  含义       与404类似，只是服务器曾经拥有过该资源
 *              411
 *                  原因短语    Length Required    
 *                  含义       服务器要求在请求报文中包含Content-Length首部时候使用
 *              412
 *                  原因短语    Precondition Failed 
 *                  含义       在 HTTP 协议中，响应状态码 412 Precondition Failed（先决条件失败）表示客户端错误，意味着对于目标资源的访问请求被拒绝。这通常发生于采用除 GET 和 HEAD 之外的方法进行条件请求时，由首部字段 If-Unmodified-Since 或 If-None-Match 规定的先决条件不成立的情况下。这时候，请求的操作——通常是上传或修改文件——无法执行，从而返回该错误状态码。
 *              413
 *                  原因短语    Payload Too Large
 *                  含义       响应状态码 413 Payload Too Large 表示请求主体的大小超过了服务器愿意或有能力处理的限度，服务器可能会（may）关闭连接以防止客户端继续发送该请求。  如果“超出限度”是暂时性的，服务器应该返回  Retry-After 首部字段，说明这是暂时性的，以及客户端可以在什么时间（after what time）后重试。
 *              414
 *                  原因短语    URI Too Long 
 *                  含义       响应码 414 URI Too Long 表示客户端所请求的 URI 超过了服务器允许的范围。
 *                            以下是造成这种罕见情况的几种可能原因：
 *                                当客户端误将 POST 请求当作 GET 请求时，会带有一个较长的查询字符串(query)；  
 *                                当客户端堕入重定向循环黑洞时，例如，指向自身后缀的重定向URI前缀(a redirected URI prefix that points to a suffix of itself)；
 *                                当客户端对服务器进行攻击，试图寻找潜在的漏洞时。
 *              415
 *                  原因短语    Unsupported Media Type    
 *                  含义       415 Unsupported Media Type 是一种HTTP协议的错误状态代码，表示服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。
 *                            格式问题的出现有可能源于客户端在 Content-Type 或 Content-Encoding 首部中指定的格式，也可能源于直接对负载数据进行检测的结果。
 *              416
 *                  原因短语    416 Range Not Satisfiable
 *                  含义         HTTP 416 Range Not Satisfiable 错误状态码意味着服务器无法处理所请求的数据区间。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range 首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。
 *              417
 *                  原因短语    Expectation Failed
 *                  含义       HTTP协议中的  417 Expectation Failed 状态码表示客户端错误，意味着服务器无法满足 Expect 请求消息头中的期望条件。
 *          
 *          500~599  服务端错误状态码
 *              500
 *                  原因短语    Internal Server Error    
 *                  含义       在 HTTP 协议中，500 Internal Server Error 是表示服务器端错误的响应状态码，意味着所请求的服务器遇到意外的情况并阻止其执行请求。
 *              501
 *                  原因短语    Not Implemented   
 *                  含义       HTTP 501 Not Implemented 服务器错误响应码表示请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法（即不会返回这个状态码的方法）只有 GET 和 HEAD。
 *                            请注意，你无法修复 501 错误，需要被访问的 web 服务器去修复该问题。
 *              502
 *                  原因短语    Bad Gateway
 *                  含义       502 Bad Gateway 是一种HTTP协议的服务器端错误状态代码，它表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。
 *              503
 *                  原因短语    Service Unavailable     
 *                  含义       503 Service Unavailable 是一种HTTP协议的服务器端错误状态代码，它表示服务器尚未处于可以接受请求的状态。
 *                            通常造成这种情况的原因是由于服务器停机维护或者已超载。注意在发送该响应的时候，应该同时发送一个对用户友好的页面来解释问题发生的原因。该种响应应该用于临时状况下，与之同时，在可行的情况下，应该在 Retry-After 首部字段中包含服务恢复的预期时间。
 *              504
 *                  原因短语    Gateway Timeout  
 *                  含义       504 Gateway Timeout 是一种HTTP协议的服务器端错误状态代码，表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。
 *                            Gateway （网关）在计算机网络体系中可以指代不同的设备，504 错误通常不是在客户端可以修复的，而是需要由途径的Web服务器或者代理服务器对其进行修复。
 *              505
 *                  原因短语    HTTP Version Not Supported   
 *                  含义       505 HTTP Version Not Supported 是一种HTTP协议的服务器端错误状态代码，表示服务器不支持请求所使用的 HTTP 版本。        
 *              
 *              
*/