/**
 *  第三章节 HTTP报文
 *      方法
 *          安全方法
 *              HTTP定义了一组被称为安全方法的方法 GET方法和HEAD方法就是安全方法 意味着GET方法和HEAD方法的HTTP请求都不会对产生什么动作
 *          GET方法
 *              GET方法是最常用的方法。通常用于请求服务器上的某个资源
 *              HTTP/1.1要求服务器端实现GET方法
 *              通常的页面访问就是GET方法
 *          HEAD方法
 *              服务器在响应中仅返回首部，不会返回实体内容
 *              这就允许客户端在未获取到实际资源的情况下，对资源的首部进行检查
 *              使用HEAD可以
 *                  在不获取资源的情况下了解资源的情况 比如判断其类型
 *                  通过查看响应中的状态码，看看某个对象是否存在
 *                  通过查看首部，测试资源是否被修改过
 *          PUT方法
 *              与GET会向服务器请求资源相反，PUT方法会向服务器写入文档
 *              PUT方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者这个URL已经存在的话，就用这个主体来替代它 
 *              因为PUT方法会对内容进行修改，所以很多Web服务器都要求在执行PUT方法前，用密码登录
 *          POST
 *              POST方法是用来向服务器输入数据的。
 *          TRACE
 *              客户端发起一个请求，很可能经过防火墙、网关或者其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子
 *              TRACE请求会在目的服务器发起一个’环回‘诊断。形成最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带他收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求和响应链上，原始报文是否，以及如何被毁坏或修改
 *              TRACE方法主要用于诊断，也就是说用于验证请求是否如愿穿过了请求/响应链。它是一种很好的工具，可以查看代理和其他应用程序对用户请求所产生的的效果
 *              TRACE缺点
 *                  TRACE假定中间应用程序对不同类型的请求处理是相同的，但是很多HTTP应用程序会根基方法的不同作出不同的事---比如，代理可能会将POST请求转发服务器，将GET请求发送给另一个HTTP应用程序。
 *                  TRACE并不提供区分这些方法的机制，通常中间应用程序会自行决定对TRACE请求的处理方式
 *              TRACE请求中不能带有实体的主体部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本 
 *          OPTIONS
 *              OPTIONS方法请求Web服务器告知其支持哪种功能，可以查询服务器通常支持哪些方法，或者对其某些特殊资源支持哪些方法（某些服务器可能只支持对一些特殊类型的对象使用特定的操作）
 *              这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判断是否可以访问改资源的最优方式
 *          DELETE
 *              DELETE方法是请服务器删除URL所指定的资源，但是客户端无法保证删除操作一定会被执行
 *              因为HTTP规范允许服务器在不通知客户端的情况下撤销请求
 *          扩展方法
 *              HTTP被设计成字段可扩展的，这样新的特性就不会使老的软件失效了。扩展方法值得就是没有在HTTP/1.1规范中定义的方法
 *              服务器会为它所管理的资源实现一些HTTP服务，这些方法为开发者提供了一种扩展这些HTTP服务能力的手段。
 *              Web扩展方法示例
 *                  LOCK        允许用户‘锁定‘资源--比如可以在编辑某个资源的时候将其锁定，以防止别人同时对其进行修改
 *                  MKCOL       允许用户创建资源
 *                  COPY        便于在服务器上复制资源
 *                  MOVE        在服务器上移动资源
 *              并不是所有扩展方法都是正式规范中定义的，认识到这一点很重要。如果你定义一个扩展方法，很可能大部分HTTP应用程序都无法理解，同样，你的HTTP应用程序也可能会遇到其他应用程序都在用，他们无法理解的扩展方法
 *              在这种情况下，对所有发出去的内容严格一点，对所接受的内容宽松一点来处理扩展方法
 *      状态码
 *          状态码为客户端提供了一种理解事务处理结果的便捷方式。
 *          尽管并没有实际的规范对原因短语的确切文本进行说明，本节还是列出了一些原因短语实例
 * 
 *          100~199  信息性状态码
 *          200~299  成功状态码
 *              客户端发起请求时，大部分都是成功的。服务端定义了部分表示成功的状态码，分别对应于不同类型的请求
 *              200
 *                  原因短语     OK
 *                  含义        请求没有问题，实体的主体部分包含了所请求的资源
 *              201
 *                  原因短语     Created
 *                  含义        用于创建服务器对象的请求(例如：PUT)，响应的实体主体部分中应该包含各种引用了已创建的资源的URL，Location首部包含的则是最具体的引用
 *                             服务器必须在发送这个状态码之前创建好对象
 *              202
 *                  原因短语     Accepted
 *                  含义        请求已被接收，但服务器还未对其进行任何动作。不能保证服务器会完成这个请求；这只意味着接收请求时，它是有效的
 *                              服务器应该在实体的主体部分包含对请求状态的描述，获取还应该有对请求完成时间的预估（或者包含一个指针，指向可以获取此信息的位置）
 *              203   
 *                  原因短语     Non-Authoritative Information
 *                  含义        表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确
 *              204
 *                  原因短语     No Content
 *                  含义        在并没有新文档的情况下，204确保浏览器继续显示先前的文档
 *                             响应报文中包含若干首部和一个状态行，但是没有实体的主体部分
 *                             主要用于在浏览器不转为显示新文档的情况下，对其进行更新（例如刷新一个表单列表）      
 *              205
 *                  原因短语     Reset Content
 *                  含义        虽然没有新文档但浏览器要重置文档显示
 *                             另一个主要用于浏览器的代码，负责告知浏览器清除当前页面中所有的HTML表单元素
 *              206
 *                  原因短语     Partial Conent
 *                  含义        成功执行了一个部分或者Range（范围）请求
 * 
 * 
*/